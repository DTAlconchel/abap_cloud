# ABAP Cloud Clean Core (RAP + EML + ABAP OO + Application Jobs)

Project built in **SAP BTP ABAP Environment (ABAP Cloud)** with a **Clean Core mindset**:
- **RAP managed BO** over custom FI-like documents (Header + Items)
- **EML** to read/update entities (both UI action + batch)
- **ABAP OO** with **Interface + Repository + Use Case** (clean separation)
- **Application Jobs** (cloud-ready background execution)

> [!NOTE]
> The backend is stored using the standard **abapGit** format (`/src`), so you can browse every object directly in GitHub.

---

## What this app covers

### 1) FI-like Domain Model (Header + Items)
We model a simple FI document structure:
- Header table: [`ZFI_DOC_H`](src/zfi_doc_h.tabl.xml)
- Item table: [`ZFI_DOC_I`](src/zfi_doc_i.tabl.xml)

Key ideas:
- UUID keys (cloud-friendly)
- Amount + currency semantics in items
- Composition-like relationship (Header → Items)

---

### 2) CDS View Entities (Root + Composition)
We expose the data model via CDS View Entities:
- Root view entity (Header): [`ZC_FI_DOC`](src/zc_fi_doc.ddls.asddls)
- Child view entity (Items): [`ZC_FI_ITEM`](src/zc_fi_item.ddls.asddls)

Important bits:
- Composition in the root (`composition [0..*] of ... as _Items`)
- Association to parent in items (`association to parent ... as _Doc`)

This is the “Clean Core friendly” pattern: **apps consume CDS**, not tables.

---

### 3) Managed RAP Behavior (CRUD + Locks + ETag + Managed Numbering)
We turn the CDS model into a transactional BO using **managed RAP**:
- Behavior definition (Root): [`ZC_FI_DOC.bdef`](src/zc_fi_doc.bdef.asbdef)
- Behavior definition (Child): [`ZC_FI_ITEM.bdef`](src/zc_fi_item.bdef.asbdef)

What’s inside:
- `managed implementation in class ...`
- `lock master` / `lock dependent`
- `etag master ...`
- `field ( numbering : managed, readonly ) ...` (UUID generated by framework)

---

### 4) “Reconcile” Action in RAP (EML in LOCAL MODE)
Users can press a button in Fiori Elements to reconcile documents:
- Behavior pool class: [`ZBP_C_FI_DOC`](src/zbp_c_fi_doc.clas.abap)
- Handler implementation (local): [`ZBP_C_FI_DOC locals`](src/zbp_c_fi_doc.clas.locals_imp.abap)

Action flow (high level):
- `READ ENTITIES` of selected headers
- `READ ENTITIES ... BY _Items` to get amounts
- Sum amounts per doc_uuid
- `MODIFY ENTITIES ... IN LOCAL MODE` to update status:
   - `'B'` if balanced (sum = 0)
   - `'E'` if not balanced
- Return `$self` so Fiori refreshes rows instantly

> [!IMPORTANT]
> In RAP actions, **don’t `COMMIT ENTITIES`** inside the handler.
> The RAP runtime controls the save sequence (buffer → validations → save).

---

### 5) ABAP OO Clean Architecture (Interface + Repo + Use Case)
Same business logic, but written like a real project:
- Repository interface (port): [`ZIF_FI_DOC_REPO`](src/zif_fi_doc_repo.intf.abap)
- Repository implementation (adapter): [`ZCL_FI_CDS`](src/zcl_fi_cds.clas.abap)
- Use Case / Application Service: [`ZCL_FI_USE_CASE`](src/zcl_fi_use_case.clas.abap)

Why this matters:
- The **Use Case** depends on the **Interface**, not the concrete class
- Tomorrow you can swap the repo to use:
  - Released standard CDS
  - Different filters / joins / buffering
  - External data source
…without changing the use case signature

---

### 6) Application Job (Background Reconciliation)
Besides the Fiori button, we can also run reconciliation in the background via **Application Jobs** (ABAP Cloud friendly).

Job class (runtime + design-time parameters):
- Background job executor: [`ZCL_FI_JOB`](src/zcl_fi_job.clas.abap)

Interfaces used:
- `IF_APJ_RT_EXEC_OBJECT` (runtime execute)
- `IF_APJ_DT_EXEC_OBJECT` (design-time parameters via `get_parameters`)

Typical runtime flow:
1. Read job parameters (e.g., Company Code)
2. Instantiate repo + use case
3. Execute reconciliation and persist results (batch = you control commit)

> [!IMPORTANT]
> This is the cloud replacement for classic SM36/SM37 + SE38 reports.

---

### 7) Developer Console Runner (ADT) for Debugging (No Fiori / No Job UI needed)
In some ABAP Cloud trial setups, you may not have access to the full Fiori Launchpad apps (or roles) to schedule/monitor jobs.
To **test and debug end-to-end**, we provide a console entrypoint runnable from ADT:

- Console runner: [`ZCL_FI_TEST_EXE`](src/zcl_fi_test_exe.clas.abap)

What it does:
- Cleans test tables
- Seeds demo data using EML
- Executes the same orchestration as the job (`repo → use case → execute`)
- Writes results to the ADT console output

Run it in ADT:
- **Right click class → Run As → ABAP Application (Console)**
- Set breakpoints and debug the full flow.

> [!NOTE]
> This class is a **developer utility**, not a “business entrypoint”.
> Business entrypoints are: **RAP action (UI)** and **Application Job (batch)**.

## How to run (high level)
1. Import repo into your ABAP system using abapGit
2. Activate all objects (tables → CDS → behaviors → classes)
3. Create some documents + items (manually, or using your own seed helper if you keep one)
4. Run reconciliation in one of two ways:
- **UI (RAP/Fiori):** trigger the Reconcile action
- **Batch (Application Job):** create a Job Template + schedule it

---

## TODO / Next improvements
- Add proper authorization checks (instance + global)
- Add currency consistency checks (header currency vs item currency)
- Add ALV/analytics view for reconciliation results
- Replace Z-tables with released standard CDS where it makes sense (real Clean Core scenario)


